
#include "rw_i2c_emu.h"

// External variables from main.c
extern uint32_t adc_usb; // USB voltage reading

uint8_t i2c_55[256];
uint8_t i2c_6b[256];
uint8_t i2c_30[256];

/*
 write to 0x55 ack data: 0x3E 0x9B 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x0D 0x31

write to 0x55 ack data: 0x3E 0x9D 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x08 0x34
write to 0x55 ack data: 0x3E 0x9F 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x08 0x34
write to 0x55 ack data: 0x3E 0xA3 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x0E 0x5F
write to 0x55 ack data: 0x3E 0xA9 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x01 0xAE
write to 0x55 ack data: 0x3E 0xAB 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x01 0x4E
write to 0x55 ack data: 0x3E 0xAD 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x12 0x12
write to 0x55 ack data: 0x3E 0xAF 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x01 0x98
write to 0x55 ack data: 0x3E 0xB1 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x0B
write to 0x55 ack data: 0x3E 0xB2 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x00
write to 0x55 ack data: 0x3E 0xBD 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x0F 0xCC
write to 0x55 ack data: 0x3E 0xBF 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x0F 0x41
write to 0x55 ack data: 0x3E 0xC1 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x0E 0xDF
write to 0x55 ack data: 0x3E 0xC3 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x0E 0x86
write to 0x55 ack data: 0x3E 0xC5 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x0E 0x3A
write to 0x55 ack data: 0x3E 0xC7 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x0E 0x01
write to 0x55 ack data: 0x3E 0xC9 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x0D 0xDA
write to 0x55 ack data: 0x3E 0xCB 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x0D 0xBA
write to 0x55 ack data: 0x3E 0xCD 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x0D 0x95
write to 0x55 ack data: 0x3E 0xCF 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x0D 0x53
write to 0x55 ack data: 0x3E 0xD1 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x0C 0xE3
write to 0x55 ack data: 0x3E 0xB4 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x0C 0xE4
write to 0x55 ack data: 0x3E 0xB7 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x0C 0xF9
write to 0x55 ack data: 0x3E 0xBA 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x0D 0x1B
write to 0x55 ack data: 0x3E 0xDE 0x91
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x01

write to 0x55 ack data: 0x3E 0x17 0x92
write to 0x55 ack data: 0x40
read to 0x55 ack data: 0x00 0x01

write to 0x55 ack data: 0x3A
read to 0x55 ack data: 0x24 0x00
//sealed
write to 0x55 ack data: 0x00 0x30 0x00
write to 0x55 ack data: 0x3A
read to 0x55 ack data: 0x26 0x00
*/

// ..\Core\Src\rw_i2c_emu.c
void addr_55_written(uint8_t reg, uint8_t value)
{
  if (reg == 0x00)
  {
    switch (value)
    {
      case 0x30:
        i2c_55[0x3A] = 0b01101110;
        break;
      case 0x01:
        i2c_55[0x40] = 0x20;
        i2c_55[0x41] = 0x02;
        break;
    }
  }

  if (reg == 0x3E)
  {
    switch (value)
    {
      case 0x9B:
        i2c_55[0x40] = 0x0D;
        i2c_55[0x41] = 0x31;
        break;
      case 0x9D:
        i2c_55[0x40] = 0x08;
        i2c_55[0x41] = 0x34;
        break;
      case 0x9F:
        i2c_55[0x40] = 0x08;
        i2c_55[0x41] = 0x34;
        break;
      case 0xA3:
        i2c_55[0x40] = 0x0E;
        i2c_55[0x41] = 0x5F;
        break;
      case 0xA9:
        i2c_55[0x40] = 0x01;
        i2c_55[0x41] = 0xAE;
        break;
      case 0xAB:
        i2c_55[0x40] = 0x01;
        i2c_55[0x41] = 0x4E;
        break;
      case 0xAD:
        i2c_55[0x40] = 0x12;
        i2c_55[0x41] = 0x12;
        break;
      case 0xAF:
        i2c_55[0x40] = 0x01;
        i2c_55[0x41] = 0x98;
        break;
      case 0xB1:
        i2c_55[0x40] = 0x0B;
        i2c_55[0x41] = 0x00;
        break;
      case 0xB2:
        i2c_55[0x40] = 0x00;
        i2c_55[0x41] = 0x00;
        break;
      case 0xBD:
        i2c_55[0x40] = 0x0F;
        i2c_55[0x41] = 0xCC;
        break;
      case 0xBF:
        i2c_55[0x40] = 0x0F;
        i2c_55[0x41] = 0x41;
        break;
      case 0xC1:
        i2c_55[0x40] = 0x0E;
        i2c_55[0x41] = 0xDF;
        break;
      case 0xC3:
        i2c_55[0x40] = 0x0E;
        i2c_55[0x41] = 0x86;
        break;
      case 0xC5:
        i2c_55[0x40] = 0x0E;
        i2c_55[0x41] = 0x3A;
        break;
      case 0xC7:
        i2c_55[0x40] = 0x0E;
        i2c_55[0x41] = 0x01;
        break;
      case 0xC9:
        i2c_55[0x40] = 0x0D;
        i2c_55[0x41] = 0xDA;
        break;
      case 0xCB:
        i2c_55[0x40] = 0x0D;
        i2c_55[0x41] = 0xBA;
        break;
      case 0xCD:
        i2c_55[0x40] = 0x0D;
        i2c_55[0x41] = 0x95;
        break;
      case 0xCF:
        i2c_55[0x40] = 0x0D;
        i2c_55[0x41] = 0x53;
        break;
      case 0xD1:
        i2c_55[0x40] = 0x0C;
        i2c_55[0x41] = 0xE3;
        break;
      case 0xB4:
        i2c_55[0x40] = 0x0C;
        i2c_55[0x41] = 0xE4;
        break;
      case 0xB7:
        i2c_55[0x40] = 0x0C;
        i2c_55[0x41] = 0xF9;
        break;
      case 0xBA:
        i2c_55[0x40] = 0x0D;
        i2c_55[0x41] = 0x1B;
        break;
      case 0xDE:
        i2c_55[0x40] = 0x01;
        i2c_55[0x41] = 0x00;
        break;
      case 0x17:
        i2c_55[0x40] = 0x00;
        i2c_55[0x41] = 0x01;
        break;
      default:
        break;
    }
  }
}

void int_to_array(uint8_t arr[], uint8_t index, int16_t value) 
{
  arr[index+1] = (value >> 8) & 0xFF; // High byte
  arr[index] = value & 0xFF;    // Low byte
}

void rw_i2c_emu_init()
{
  int_to_array(i2c_55, 0x06, (273+20)*10);//temperature
  int_to_array(i2c_55, 0x08, 3400);       // voltage
  int_to_array(i2c_55, 0x0C, 20);     // current
  int_to_array(i2c_55, 0x2C, 80);      // charge percentage
  int_to_array(i2c_55, 0x2E, 100);       // health
  i2c_55[0x0A] = 0b00111011;           // 1 bit - set when discarging
  i2c_55[0x0B] = 0b01000000;           // 2 bit - full charge
  i2c_55[0x3A] = 0b01101100;

  i2c_6b[0x0B] = 0b00000010; // not charging
  i2c_6b[0x0E] = 100;        // batv
  i2c_6b[0x0F] = 100;        // sysv
  i2c_6b[0x11] = 4000; // vbus
  
  //i2c_6b[0x0B] = 0b00110110; // charging
  //i2c_6b[0x0B] = 0b00111110; // charged
}

void rw_i2c_set_battery(int16_t vbatt,int16_t vusb,int16_t current, uint8_t charge_state) 
{
  if (charge_state == 0)
  {
    i2c_55[0x0A] = 0b00111011; // 1 bit - set when discarging
    i2c_6b[0x0B] = 0b00000010; // not charging
  }
  else if (charge_state == 1)
  {
    i2c_55[0x0A] = 0b00111010; 
    i2c_6b[0x0B] = 0b00110110; // charging
  }
  else if (charge_state == 2)
  {
    i2c_55[0x0A] = 0b00111110; // 
    i2c_6b[0x0B] = 0b00111110; // charged
  }
  int_to_array(i2c_55, 0x08, vbatt); // voltage
  int_to_array(i2c_55, 0x0C, current);   // current
  int_to_array(i2c_55, 0x2C, (vbatt-3200)*100/(4200-3200));   // charge percentage 
}

void rw_i2c_reg_written(uint8_t address, uint8_t reg, uint8_t value)
{
  if (address == 0x6b)
  {
    i2c_6b[reg] = value;
    
    // Check for shutdown signal (similar to BQ25896 BATFET_DIS)
    // Register 0x09 with bit 5 set indicates battery disconnect/shutdown request
    if (reg == 0x09 && (value & 0x20)) { // Check bit 5 (BATFET_DIS equivalent)
      // Queue shutdown to be handled in main loop context (avoid heavy work in ISR)
      extern void queue_shutdown_request(void);
      queue_shutdown_request();
    }
  }
  else if (address == 0x30)
  {
    i2c_30[reg] = value;
  }
  else if (address == 0x55)
  {
    //i2c_55[reg] = value
    addr_55_written(reg,value);
  }
}

uint8_t rw_i2c_get_reg(uint8_t address, uint8_t reg)
{
  if (address == 0x6b)
  {
	return i2c_6b[reg];
  }
  else if (address == 0x30)
  {
	return i2c_30[reg];
  }
  else if (address == 0x55)
  {
	return i2c_55[reg];
  }
  return 0;
}

uint8_t rw_i2c_get_backlight()
{
 return i2c_30[14];
}